#!/bin/sh /etc/rc.common
# Copyright (C) 2018-2019 Lienol <lawlienol@gmail.com>

START=99

CONFIG=v2ray_server
CONFIG_PATH=/var/etc/$CONFIG
CONFIG_NGINX_PATH=$CONFIG_PATH/nginx
CONFIG_CADDY_PATH=$CONFIG_PATH/caddy
LOG_PATH=/var/log/$CONFIG
LOG_APP_FILE=$LOG_PATH/app.log
LOG_NGINX_PATH=$LOG_PATH/nginx
LOG_CADDY_PATH=$LOG_PATH/caddy

echolog() {
	echo -e "$(date "+%Y-%m-%d %H:%M:%S"): $1" >> $LOG_APP_FILE
}

gen_v2ray_config_file() {
	config_get enable $1 enable
	[ "$enable" = "0" ] && return 0
	config_get remarks $1 remarks
	config_get port $1 port
	config_get transport $1 transport
	lua /usr/lib/lua/luci/model/cbi/v2ray_server/api/genv2rayconfig.lua $1 > $CONFIG_PATH/$1.json
	echolog "$remarks $port 生成并运行 V2ray 配置文件 - $CONFIG_PATH/$1.json" 
	/usr/bin/v2ray/v2ray -config $CONFIG_PATH/$1.json >/dev/null 2>&1 &
	
	is_run=`ps -w| grep -v grep | grep "$CONFIG_PATH/$1.json"`
	if [ -z "$is_run" ];then
		echolog "$remarks $port V2ray 运行失败" 
	else
		echolog "$remarks $port V2ray 运行成功" 
		config_get reverse_proxy_enable $1 reverse_proxy_enable
		config_get reverse_proxy_type $1 reverse_proxy_type
		config_get reverse_proxy_port $1 reverse_proxy_port
		config_get reverse_proxy_serverName $1 reverse_proxy_serverName
		config_get reverse_proxy_https_enable $1 reverse_proxy_https_enable
		[ "$reverse_proxy_enable" = "1" -a "$reverse_proxy_type" = "nginx" ] && {
			echolog "$remarks $port 生成并运行Nginx配置文件 - $CONFIG_NGINX_PATH/$1.conf" 
			cat <<-EOF > $CONFIG_NGINX_PATH/$1.conf
				user root root;
				worker_processes  1;
				#pid /var/run/nginx_v2ray_$1.pid;
				events {
					worker_connections  51200;
				}
			EOF
			
			ssl_params=''
			is_ssl=''
			location_path=''
			
			if [ "$transport" = "ws" ];then
				config_get ws_path $1 ws_path
				location_path=$ws_path
			elif [ "$transport" = "h2" ];then
				config_get h2_path $1 h2_path
				location_path=$h2_path
			fi
			
			if [ "$reverse_proxy_https_enable" = "1" ];then
				config_get reverse_proxy_https_certificateFile $1 reverse_proxy_https_certificateFile
				config_get reverse_proxy_https_keyFile $1 reverse_proxy_https_keyFile
				is_ssl='ssl'
				ssl_params="ssl_certificate ${reverse_proxy_https_certificateFile};\nssl_certificate_key ${reverse_proxy_https_keyFile};\nssl_protocols TLSv1 TLSv1.1 TLSv1.2;\nssl_ciphers HIGH:!aNULL:!MD5;"
			fi
				
			cat <<-EOF >> $CONFIG_NGINX_PATH/$1.conf
					http
						{
							include       /etc/nginx/mime.types;
							default_type  application/octet-stream;
							sendfile        on;
							keepalive_timeout  65;
							server_tokens  off;
							
						server {
							server_name $reverse_proxy_serverName;
							listen $reverse_proxy_port $(echo $is_ssl);
							$(echo -e $ssl_params)
							charset UTF-8;
							access_log  $LOG_NGINX_PATH/$1_access.log;
							
							location $location_path {
								proxy_redirect off;
								proxy_pass http://127.0.0.1:$port;
								proxy_http_version 1.1;
								proxy_set_header Upgrade \$http_upgrade;
								proxy_set_header Connection "upgrade";
								#proxy_set_header Host \$http_host;

								proxy_set_header X-Real-IP \$remote_addr;
								proxy_set_header Host \$host;
								proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
							}
						}
					}
			EOF
			
			/usr/sbin/nginx -c $CONFIG_NGINX_PATH/$1.conf
			
			is_run=`ps -w| grep -v grep | grep "/usr/sbin/nginx -c $CONFIG_NGINX_PATH/$1.conf"`
			if [ -z "$is_run" ];then
				echolog "$remarks $port Nginx 运行失败" 
			else
				echolog "$remarks $port Nginx 运行成功" 
			fi
		}
		
		[ "$reverse_proxy_enable" = "1" -a "$reverse_proxy_type" = "caddy" ] && {
			host="http://$reverse_proxy_serverName:$reverse_proxy_port"
			gzip=""
			location_path=''
			websocket=''
			header_upstream=''
			proxy_path="http://127.0.0.1:$port"
			if [ "$transport" = "ws" ];then
				config_get ws_path $1 ws_path
				location_path=$ws_path
				gzip="gzip"
				websocket="websocket"
			elif [ "$transport" = "h2" ];then
				config_get h2_path $1 h2_path
				location_path=$h2_path
				proxy_path="https://127.0.0.1:$port"
				header_upstream="header_upstream X-Forwarded-Proto 'https'\nheader_upstream Host \"$reverse_proxy_serverName\""
			fi
			if [ "$reverse_proxy_https_enable" = "1" ];then
				config_get reverse_proxy_https_certificateFile $1 reverse_proxy_https_certificateFile
				config_get reverse_proxy_https_keyFile $1 reverse_proxy_https_keyFile
				host="https://$reverse_proxy_serverName:$reverse_proxy_port"
				ssl_params="tls ${reverse_proxy_https_certificateFile} ${reverse_proxy_https_keyFile} {\nprotocols tls1.2 tls1.3\nciphers ECDHE-ECDSA-WITH-CHACHA20-POLY1305 ECDHE-RSA-WITH-CHACHA20-POLY1305 ECDHE-ECDSA-AES128-GCM-SHA256 ECDHE-RSA-AES128-GCM-SHA256\n}"
			fi
		
			echolog "$remarks $port 生成并运行Caddy配置文件 - $CONFIG_CADDY_PATH/$1.conf" 
			cat <<-EOF > $CONFIG_CADDY_PATH/$1
				$host
				{
					$gzip
					timeouts none
					proxy / https://www.baidu.com
					$(echo -e $ssl_params)
					header / {
						Strict-Transport-Security "max-age=15768000; preload"
						X-XSS-Protection "1; mode=block"
						X-Content-Type-Options "nosniff"
						X-Frame-Options "DENY"
					}
					proxy $location_path $proxy_path {
						$websocket
						header_upstream -Origin
						$(echo -e $header_upstream)
					}
				}
			EOF
			
			if [ -f "$caddy_file" ];then
				$caddy_file -conf $CONFIG_CADDY_PATH/$1 -log $LOG_CADDY_PATH/$1 >> $LOG_APP_FILE && 2>&1 &
			else
				echolog "未安装Caddy，请安装后再重试"
			fi
		}
	fi
}

start_v2ray_server() {
	ulimit -n 8192
	mkdir -p $CONFIG_PATH $CONFIG_CADDY_PATH $CONFIG_NGINX_PATH $LOG_PATH $LOG_CADDY_PATH $LOG_NGINX_PATH /var/lib/nginx /var/log/nginx
	touch $LOG_APP_FILE
	caddy_file=$(uci get $CONFIG.@global[0].caddy_file)
	config_foreach gen_v2ray_config_file "user"
	fw3 reload >/dev/null 2>&1 &
}

stop_v2ray_server() {
	fw3 reload >/dev/null 2>&1 &
	nginx_run=`ps -w | grep "$CONFIG_NGINX_PATH/" | grep -v "grep" | awk '{print $10}'`
	for i in $nginx_run
	do
		/usr/sbin/nginx -c $i -s stop
	done
	ps -w | grep "$CONFIG_CADDY_PATH/" | grep -v "grep" | awk '{print $1}' | xargs kill -9 >/dev/null 2>&1 &
	ps -w | grep "$CONFIG_PATH/" | grep -v "grep" | awk '{print $1}' | xargs kill -9 >/dev/null 2>&1 &
	rm -rf $CONFIG_PATH
	rm -rf $LOG_PATH
}

start() {
	config_load $CONFIG
	enable=$(uci get $CONFIG.@global[0].enable)
	if [ "$enable" = "0" ];then
		stop_v2ray_server
	else
		start_v2ray_server
	fi
}

stop() {
	stop_v2ray_server
}

restart() {
	stop
	sleep 1
	start
}